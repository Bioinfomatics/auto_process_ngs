#!/bin/env python
#
#     auto_process_utils: utility classes & funcs for auto_process module
#     Copyright (C) University of Manchester 2013 Peter Briggs
#
########################################################################
#
# auto_process_utils.py
#
#########################################################################

__version__ = "0.0.1"

"""auto_process_utils

Utility classes and functions to support auto_process module.

Ultimately these should be relocated in the main 'genomics' code
tree at some point.

"""

#######################################################################
# Imports
#######################################################################

import os
import logging
import IlluminaData
import Pipeline
import qcreporter
import bcf_utils

#######################################################################
# Classes
#######################################################################

class AttributeDict:
    """Dictionary-like object with items accessible as attributes

    AttributeDict provides a dictionary-like object where the value
    of items can also be accessed as attributes of the object.

    For example:

    >>> d = AttributeDict()
    >>> d['salutation'] = "hello"
    >>> d.salutation
    ... "hello"

    Attributes can only be assigned by using dictionary item assignment
    notation i.e. d['key'] = value. d.key = value doesn't work.

    If the attribute doesn't match a stored item then an
    AttributeError exception is raised.

    len(d) returns the number of stored items.

    The AttributeDict behaves like a dictionary for iterations, for
    example:

    >>> for attr in d:
    >>>    print "%s = %s" % (attr,d[attr])

    """
    # Dictionary-like object that allows
    # elements to be accessed as attributes
    def __init__(self,**args):
        self.__dict = dict(args)

    def __getattr__(self,attr):
        try:
            return self.__dict[attr]
        except KeyError:
            raise AttributeError, "No attribute '%s'" % attr

    def __getitem__(self,key):
        return self.__dict[key]

    def __setitem__(self,key,value):
        self.__dict[key] = value

    def __iter__(self):
        return iter(self.__dict)

    def __len__(self):
        return len(self.__dict)

class AnalysisFastq:
    """Class for extracting information about Fastq files

    Given the name of a Fastq file, extract data about the sample name,
    barcode sequence, lane number, read number and set number.

    The name format can be a 'full' Fastq name as generated by CASAVA,
    which follows the general form:

    <sample_name>_<barcode_sequence>_L<lane_number>_R<read_number>_<set_number>.fastq.gz

    e.g. for

    NA10831_ATCACG_L002_R1_001.fastq.gz

    sample_name = 'NA10831_ATCACG_L002_R1_001'
    barcode_sequence = 'ATCACG'
    lane_number = 2
    read_number = 1
    set_number = 1

    Alternatively it can be a 'reduced' version where one or more
    of the components has been omitted (typically because they are
    redundant in uniquely distinguishing a Fastq file within a
    set of Fastqs).

    The reduced formats are:

    <sample_name>
    <sample_name>_L<lane_number>
    <sample_name>_<barcode_sequence>
    <sample_name>_<barcode_sequence>_L<lane_number>

    with an optional suffix '_R<read_number>' for paired end sets.

    e.g.

    NA10831
    NA10831_L002
    NA10831_ATCACG
    NA10831_ATCACG_L002

    Provides the follow attributes:

    fastq:            the original fastq file name
    sample_name:      name of the sample (leading part of the name)
    barcode_sequence: barcode sequence (string or None)
    lane_number:      integer (or None if no lane number)
    read_number:      integer (or None if no read number)
    set_number:       integer (or None if no set number)

    """

    def __init__(self,fastq):
        """Create and populate a new AnalysisFastq object

        Arguments:
          fastq: name of the fastq.gz (optionally can include leading path)

        """
        # Store name
        self.fastq = fastq
        # Values derived from the name
        self.sample_name = None
        self.barcode_sequence = None
        self.lane_number = None
        self.read_number = None
        self.set_number = None
        # Base name for sample (no leading path or extension)
        fastq_base = os.path.basename(fastq)
        try:
            i = fastq_base.index('.')
            fastq_base = fastq_base[:i]
        except ValueError:
            pass
        # Identify which part of the name is which
        #
        # Full Illumina-style names are e.g.
        # NH1_ChIP-seq_Gli1_ACAGTG_L001_R1_001
        #
        # We have shorter name formats where redundant parts are
        # omitted, the patterns are:
        # NAME          e.g. NH1_ChIP-seq_Gli1
        # NAME+LANE     e.g. NH1_ChIP-seq_Gli1_L001
        # NAME+TAG      e.g. NH1_ChIP-seq_Gli1_ACAGTG
        # NAME+TAG+LANE e.g. NH1_ChIP-seq_Gli1_ACAGTG_L001
        #
        # Also read number (i.e. R1 or R2) is appended but only for
        # paired end samples
        #
        # The set number is never included, except for full names
        fields = fastq_base.split('_')
        # Deal with set number first e.g. 001
        field = fields[-1]
        ##logging.debug("Test for set number %s" % field)
        if len(field) == 3 and field.isdigit():
            self.set_number = int(field)
            fields = fields[:-1]
        # Deal with trailing read number e.g. R1
        field = fields[-1]
        ##logging.debug("Test for read number %s" % field)
        if len(field) == 2 and field.startswith('R'):
            self.read_number = int(field[1])
            fields = fields[:-1]
        # Deal with trailing lane number e.g. L001
        field = fields[-1]
        ##logging.debug("Test for lane number %s" % field)
        if len(field) == 4 and field.startswith('L') and field[1:].isdigit():
            self.lane_number = int(field[1:])
            fields = fields[:-1]
        # Deal with trailing index tag e.g. ATTGCT or ATTGCT-CCTAAG
        field = fields[-1]
        ##logging.debug("Test for barcode sequence %s" % field)
        is_tag = True
        for f in field.split('-'):
            for c in f:
                is_tag = is_tag and c in 'ACGTN'
        if is_tag:
            self.barcode_sequence = field
            fields = fields[:-1]
            ##logging.debug("Identified barcode sequence as %s" % self.barcode_sequence)
        # What's left is the name
        ##logging.debug("Remaining fields: %s" % fields)
        self.sample_name = '_'.join(fields)

    def __repr__(self):
        """Implement __repr__ built-in

        """
        if self.set_number is not None:
            # Return the full name
            fq = "%s_%s_L%03d_R%d_%03d" % (self.sample_name,
                                           'NoIndex' \
                                           if self.barcode_sequence is None \
                                           else self.barcode_sequence,
                                           self.lane_number,
                                           self.read_number,
                                           self.set_number)
        else:
            # Reconstruct partial name
            fq = "%s" % self.sample_name
            if self.barcode_sequence is not None:
                fq = "%s_%s" % (fq,self.barcode_sequence)
            if self.lane_number is not None:
                fq = "%s_L%03d" % (fq,self.lane_number)
            if self.read_number is not None:
                fq = "%s_R%d" % (fq,self.read_number)
        return fq
        
class AnalysisProject:
    # Class describing an analysis project
    # i.e. set of samples from a single sequencing experiment
    # THINKS can code be shared with IlluminaProject?
    def __init__(self,name,dirn,library_type=None,organism=None):
        # name = project name
        # dirn = directory path
        self.name = name
        self.dirn = os.path.abspath(dirn)
        self.library_type = library_type
        self.organism = organism
        self.samples = []
        self.paired_end = False
        self.fastq_dir = None
        self.populate()

    def populate(self):
        # Identify samples and related files and
        # populate the data structure
        #
        if not os.path.exists(self.dirn):
            # Nothing to do, yet
            return
        # Locate fastq files
        self.fastq_dir = os.path.join(self.dirn,'fastqs')
        if not os.path.exists(self.fastq_dir):
            # If special 'fastqs' doesn't exist then
            # look in top level of project
            fastq_dir = self.dirn
        # Populate from fastq file names
        logging.debug("Acquiring fastqs...")
        fastqs = Pipeline.GetFastqGzFiles(self.fastq_dir)
        logging.debug("Assigning fastqs to samples...")
        for fastq in fastqs:
            # GetFastqGzFile returns a list of tuples
            for fq in fastq:
                name = AnalysisFastq(fq).sample_name
                try:
                    sample = self.get_sample(name)
                except KeyError:
                    sample = AnalysisSample(name)
                    self.samples.append(sample)
                sample.add_fastq(os.path.join(self.fastq_dir,fq))
        logging.debug("Listing samples and files:")
        for sample in self.samples:
            logging.debug("* %s: %s" % (sample.name,sample.fastq))

    def create_directory(self,illumina_project=None):
        """Create and populate analysis directory for an IlluminaProject

        Creates a new directory corresponding to the AnalysisProject
        object, and optionally also populates with links to FASTQ files
        from a supplied IlluminaProject object.

        The directory structure it creates is:

        dir/
           fastqs/
           logs/
           ScriptCode/

        Arguments:
          illumina_project: (optional) populated IlluminaProject object
            from which the analysis directory will be populated
    
        """
        print "Creating analysis directory for project '%s'" % self.name
        # Check for & create directory
        if os.path.exists(self.dirn):
            print "-> %s already exists" % self.dirn
        else:
            print "Making analysis directory %s" % self.dirn
            bcf_utils.mkdir(self.dirn,mode=0775)
        # Make a 'logs' directory
        log_dir = os.path.join(self.dirn,'logs')
        bcf_utils.mkdir(log_dir,mode=0775)
        # Make a 'ScriptCode' directory
        scriptcode_dir = os.path.join(self.dirn,"ScriptCode")
        bcf_utils.mkdir(scriptcode_dir,mode=0775)
        # Make a 'fastqs' directory
        fastqs_dir = os.path.join(self.dirn,"fastqs")
        bcf_utils.mkdir(fastqs_dir,mode=0775)
        # Check for & create links to fastq files
        if illumina_project is not None:
            for sample in illumina_project.samples:
                fastq_names = IlluminaData.get_unique_fastq_names(sample.fastq)
                for fastq in sample.fastq:
                    fastq_file = os.path.join(sample.dirn,fastq)
                    fastq_ln = os.path.join(fastqs_dir,fastq_names[fastq])
                    if os.path.exists(fastq_ln):
                        logging.warning("Link %s already exists" % fastq_ln)
                    else:
                        logging.debug("Linking to %s" % fastq)
                        bcf_utils.mklink(fastq_file,fastq_ln,relative=True)
        # Populate
        self.populate()

    @property
    def qc_dir(self):
        # Return path to qc dir, if present
        qc_dir = os.path.join(self.dirn,'qc')
        if os.path.exists(qc_dir):
            return qc_dir
        else:
            return None

    @property
    def qc_report(self):
        # Create zipped QC report and return name of zip file
        if self.qc_dir is not None and self.verify_qc():
            return qcreporter.IlluminaQCReporter(self.dirn).zip()
        else:
            return None

    def verify_qc(self):
        # Verify if the QC was successful
        if self.qc_dir is None:
            return False
        return qcreporter.IlluminaQCReporter(self.dirn).verify()

    def get_sample(self,name):
        """Return sample that matches 'name'

        Arguments:
          name: name of a sample

        Returns:
          AnalysisSample object with the matching name; raises
          KeyError exception if no match is found.

        """
        for sample in self.samples:
            if sample.name == name: return sample
        raise KeyError, "No matching sample for '%s'" % name

    def get_samples(self,pattern):
        """Return list of sample matching pattern

        Arguments:
          pattern: simple 'glob' style pattern

        Returns:
          Python list of samples with names matching the supplied
          pattern (or an empty list if no names match).

        """
        samples = []
        for sample in self.samples:
            if bcf_utils.name_matches(sample.name,pattern):
                samples.append(sample)
        return samples

    def prettyPrintSamples(self):
        """Return a nicely formatted string describing the sample names

        Wraps a call to 'pretty_print_names' function.
        """
        return bcf_utils.pretty_print_names(self.samples)

class AnalysisSample:
    # Class describing an analysis sample
    # i.e. set of fastqs from a single sample
    # Can be paired end and have multiple fastqs per
    # THINKS can code be shared with IlluminaSample?
    def __init__(self,name):
        self.name = name
        self.fastq = []
        self.paired_end = False

    def add_fastq(self,fastq):
        """Add a reference to a fastq file in the sample

        Arguments:
          fastq: name of the fastq file
        """
        self.fastq.append(fastq)
        # Sort fastq's into order
        self.fastq.sort()
        # Check paired-end status
        if not self.paired_end:
            fq = AnalysisFastq(fastq)
            if fq.read_number == 2:
                self.paired_end = True

    def fastq_subset(self,read_number=None,full_path=False):
        """Return a subset of fastq files from the sample

        Arguments:
          read_number: select subset based on read_number (1 or 2)
          full_path  : if True then fastq files will be returned
            with the full path, if False (default) then as file
            names only.

        Returns:
          List of fastq files matching the selection criteria.

        """
        # Build list of fastqs that match the selection criteria
        fastqs = []
        for fastq in self.fastq:
            fq = AnalysisFastq(fastq)
            if fq.read_number is None:
                raise Exception, \
                    "Unable to determine read number for %s" % fastq
            if fq.read_number == read_number:
                if full_path:
                    fastqs.append(os.path.join(self.dirn,fastq))
                else:
                    fastqs.append(fastq)
        # Sort into dictionary order and return
        fastqs.sort()
        return fastqs

    def verify_qc(self,qc_dir,fastq):
        """
        """
        verified = True
        name = bcf_utils.rootname(os.path.basename(fastq))
        qc_sample = qcreporter.IlluminaQCSample(name,qc_dir)
        return qc_sample.verify()

    def __repr__(self):
        """Implement __repr__ built-in

        Return string representation for the sample -
        i.e. the sample name.

        """
        return str(self.name)

#######################################################################
# Tests
#######################################################################

import unittest

class TestAttributeDict(unittest.TestCase):
    """Tests for the AttributeDict class

    """

    def test_set_get_items(self):
        """Test 'set' and 'get' using dictionary notation
        """
        d = AttributeDict()
        self.assertEqual(len(d),0)
        d['salutation'] = 'hello'
        self.assertEqual(len(d),1)
        self.assertEqual(d["salutation"],"hello")

    def test_get_attrs(self):
        """Test 'get' using attribute notation
        """
        d = AttributeDict()
        self.assertEqual(len(d),0)
        d['salutation'] = 'hello'
        self.assertEqual(len(d),1)
        self.assertEqual(d.salutation,"hello")

    def test_init(self):
        """Test initialising like a standard dictionary
        """
        d = AttributeDict(salutation='hello',valediction='goodbye')
        self.assertEqual(len(d),2)
        self.assertEqual(d.salutation,"hello")
        self.assertEqual(d.valediction,"goodbye")

    def test_iter(self):
        """Test iteration over items
        """
        d = AttributeDict()
        self.assertEqual(len(d),0)
        d['salutation'] = 'hello'
        d['valediction'] = 'goodbye'
        self.assertEqual(len(d),2)
        self.assertEqual(d.salutation,"hello")
        self.assertEqual(d.valediction,"goodbye")
        for key in d:
            self.assertTrue(key in ('salutation','valediction'),
                            "%s not in list" % key)

class TestAnalysisFastq(unittest.TestCase):
    """Tests for the AnalysisFastq class

    """

    def test_full_name(self):
        """Handle full Illumina-style fastq name
        """
        fq = AnalysisFastq('NH1_ChIP-seq_Gli1_ACAGTG_L003_R2_001')
        self.assertEqual(fq.sample_name,'NH1_ChIP-seq_Gli1')
        self.assertEqual(fq.barcode_sequence,'ACAGTG')
        self.assertEqual(fq.lane_number,3)
        self.assertEqual(fq.read_number,2)
        self.assertEqual(fq.set_number,1)
        self.assertEqual(str(fq),'NH1_ChIP-seq_Gli1_ACAGTG_L001_R1_001')

    def test_full_name(self):
        """Handle full Illumina-style fastq name with dual index
        """
        fq = AnalysisFastq('NH1_ChIP-seq_Gli1_ACAGTG-GTTCAC_L003_R2_001')
        self.assertEqual(fq.sample_name,'NH1_ChIP-seq_Gli1')
        self.assertEqual(fq.barcode_sequence,'ACAGTG-GTTCAC')
        self.assertEqual(fq.lane_number,3)
        self.assertEqual(fq.read_number,2)
        self.assertEqual(fq.set_number,1)
        self.assertEqual(str(fq),'NH1_ChIP-seq_Gli1_ACAGTG-GTTCAC_L003_R2_001')

    def test_name_only(self):
        """Handle reduced fastq name (sample name only)
        """
        fq = AnalysisFastq('NH1_ChIP-seq_Gli1')
        self.assertEqual(fq.sample_name,'NH1_ChIP-seq_Gli1')
        self.assertEqual(fq.barcode_sequence,None)
        self.assertEqual(fq.lane_number,None)
        self.assertEqual(fq.read_number,None)
        self.assertEqual(fq.set_number,None)
        self.assertEqual(str(fq),'NH1_ChIP-seq_Gli1')

    def test_name_only_paired_end(self):
        """Handle reduced fastq name (sample name only, paired end)
        """
        fq = AnalysisFastq('NH1_ChIP-seq_Gli1_R2')
        self.assertEqual(fq.sample_name,'NH1_ChIP-seq_Gli1')
        self.assertEqual(fq.barcode_sequence,None)
        self.assertEqual(fq.lane_number,None)
        self.assertEqual(fq.read_number,2)
        self.assertEqual(fq.set_number,None)
        self.assertEqual(str(fq),'NH1_ChIP-seq_Gli1_R2')

    def test_name_and_lane(self):
        """Handle reduced fastq name (sample name and lane)
        """
        fq = AnalysisFastq('NH1_ChIP-seq_Gli1_L001')
        self.assertEqual(fq.sample_name,'NH1_ChIP-seq_Gli1')
        self.assertEqual(fq.barcode_sequence,None)
        self.assertEqual(fq.lane_number,1)
        self.assertEqual(fq.read_number,None)
        self.assertEqual(fq.set_number,None)
        self.assertEqual(str(fq),'NH1_ChIP-seq_Gli1_L001')

    def test_name_and_lane_paired_end(self):
        """Handle reduced fastq name (sample name and lane, paired end)
        """
        fq = AnalysisFastq('NH1_ChIP-seq_Gli1_L001_R2')
        self.assertEqual(fq.sample_name,'NH1_ChIP-seq_Gli1')
        self.assertEqual(fq.barcode_sequence,None)
        self.assertEqual(fq.lane_number,1)
        self.assertEqual(fq.read_number,2)
        self.assertEqual(fq.set_number,None)
        self.assertEqual(str(fq),'NH1_ChIP-seq_Gli1_L001_R2')

    def test_name_and_tag(self):
        """Handle reduced fastq name (sample name and barcode)
        """
        fq = AnalysisFastq('NH1_ChIP-seq_Gli1_ACAGTG')
        self.assertEqual(fq.sample_name,'NH1_ChIP-seq_Gli1')
        self.assertEqual(fq.barcode_sequence,'ACAGTG')
        self.assertEqual(fq.lane_number,None)
        self.assertEqual(fq.read_number,None)
        self.assertEqual(fq.set_number,None)
        self.assertEqual(str(fq),'NH1_ChIP-seq_Gli1_ACAGTG')

    def test_name_and_tag_paired_end(self):
        """Handle reduced fastq name (sample name and barcode, paired end)
        """
        fq = AnalysisFastq('NH1_ChIP-seq_Gli1_ACAGTG_R2')
        self.assertEqual(fq.sample_name,'NH1_ChIP-seq_Gli1')
        self.assertEqual(fq.barcode_sequence,'ACAGTG')
        self.assertEqual(fq.lane_number,None)
        self.assertEqual(fq.read_number,2)
        self.assertEqual(fq.set_number,None)
        self.assertEqual(str(fq),'NH1_ChIP-seq_Gli1_ACAGTG_R2')

    def test_name_tag_and_lane(self):
        """Handle reduced fastq name (sample name, barcode and lane)
        """
        fq = AnalysisFastq('NH1_ChIP-seq_Gli1_ACAGTG_L001')
        self.assertEqual(fq.sample_name,'NH1_ChIP-seq_Gli1')
        self.assertEqual(fq.barcode_sequence,'ACAGTG')
        self.assertEqual(fq.lane_number,1)
        self.assertEqual(fq.read_number,None)
        self.assertEqual(fq.set_number,None)
        self.assertEqual(str(fq),'NH1_ChIP-seq_Gli1_ACAGTG_L001')

    def test_name_tag_and_lane_paired_end(self):
        """Handle reduced fastq name (sample name, barcode and lane, paired end)
        """
        fq = AnalysisFastq('NH1_ChIP-seq_Gli1_ACAGTG_L001_R2')
        self.assertEqual(fq.sample_name,'NH1_ChIP-seq_Gli1')
        self.assertEqual(fq.barcode_sequence,'ACAGTG')
        self.assertEqual(fq.lane_number,1)
        self.assertEqual(fq.read_number,2)
        self.assertEqual(fq.set_number,None)
        self.assertEqual(str(fq),'NH1_ChIP-seq_Gli1_ACAGTG_L001_R2')

#######################################################################
# Main program: run tests
#######################################################################

if __name__ == "__main__":
    # Turn off most logging output for tests
    logging.getLogger().setLevel(logging.CRITICAL)
    # Run tests
    unittest.main()
